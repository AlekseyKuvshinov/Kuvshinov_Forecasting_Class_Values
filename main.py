# -*- coding: utf-8 -*-
"""Kuvshinov_Forecasting.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eD7hBTUWoIoY8HvldvQPaoOnC1pZe5ks

#Часть 1. Прогнозирование временного ряда
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
from scipy import stats
import statsmodels.api as sm
from statsmodels.tsa.seasonal import seasonal_decompose
from statsmodels.tsa.ar_model import AutoReg
from sklearn.linear_model import LinearRegression
import xgboost as xgb
import numpy as np
import matplotlib.pyplot as plt
from prophet import Prophet
import json

"""Prophet"""

data = pd.read_csv('data.csv', parse_dates=True, decimal=',', index_col = ['дата'], dayfirst=True)
data = data.assign(направление=data['направление'].map({'л': 1, 'ш': 0})) \
           .sort_values('дата') \
           .reset_index() \
           .rename(columns={'дата': 'ds', 'выход': 'y'})
data

plt.figure(figsize=(15,7))
plt.plot(data['y'])
plt.show(block=False)
plt.plot('Тренд и сезонность')
plt.pause(3)

#Проверяем ряд на стационарность тестом Дики-Фуллера
print(sm.tsa.stattools.adfuller(data['y'])[0])
print(sm.tsa.stattools.adfuller(data['y'])[1])
#Видим, что p-value больше 0.05 (не можем отвергнуть гипотезу о нестационарности), поэтому вычтем тренд и сезонность, воспользовавшись statsmodels

parts = seasonal_decompose(data['y'], model='additive',period=89)
trend = parts.trend
trend = trend.interpolate(method='linear').fillna(method='bfill').fillna(method='ffill')
plt.plot(trend)
seasonal = parts.seasonal
seasonal = seasonal.fillna(seasonal.mean())
plt.plot(seasonal)
plt.show(block=False)
plt.pause(3)

data['y_stationary']=data['y']-trend-seasonal
plt.figure(figsize=(15,7))
plt.plot(data['y_stationary'])
plt.title('Стационарный ряд')
plt.show(block=False)
plt.pause(3)

print(sm.tsa.stattools.adfuller(data['y_stationary'])[0])
print(sm.tsa.stattools.adfuller(data['y_stationary'])[1])
#Теперь можно утверждать, что временной ряд стационарный

df_prophet = pd.DataFrame({'ds':data['ds'].values, 'y':data['y_stationary'].values})
#Убираем в модели Prophet сезонность, мы её вычли из временного ряда
model = Prophet(daily_seasonality=False, weekly_seasonality=False)
model.fit(df_prophet)

# Создание DataFrame для будущих дат
future = model.make_future_dataframe(periods=40)  # Прогноз на 40 дней вперед

# Прогнозирование
forecast = model.predict(future)

# Визуализация прогноза (без тренда и сезонности)
fig = model.plot(forecast)
plt.title('Прогноз с использованием Prophet')
plt.show(block=False)
plt.pause(3)

#предсказываем тренд и сезонность отдельно
train_trend = np.arange(len(trend))
train_trend = np.resize(train_trend, (len(trend), 1))
model_linear = LinearRegression()
#Примерно с 250ого отсчета прослеживается явный тренд
model_linear.fit(train_trend[248:], trend.values[248:])

test_trend = np.arange(len(trend),len(trend)+40).reshape(-1,1)
trend_predict = model_linear.predict(test_trend)

train_seasonal = seasonal.values[-365:]
#Число лагов в модели AutoReg для сезонности берем небольшой, чтобы прогноз был достаточно гладким
model_autoreg = AutoReg(train_seasonal, lags=12).fit()

seasonal_predict = model_autoreg.predict(start = len(train_seasonal), end=len(train_seasonal)+40-1)

final_predict = round(forecast.yhat[749:789] + trend_predict + seasonal_predict,2)

plt.figure(figsize=(15,7))
plt.plot(data['ds'],data['y'])
plt.plot(future['ds'][749:789],final_predict)
plt.title('Исходный временной ряд и предсказание')
plt.show(block=False)
plt.pause(2)

with open('forecast_value.json', 'w') as file:
    json.dump(final_predict.tolist(), file)

"""#Часть 2. Бинарная классификация"""

data['lag2']=data['y'].shift(2)
data['lag3']=data['y'].shift(3)
data['y_lag2']=data['y']-data['lag2']
data['y_lag3']=data['y']-data['lag3']
data['MovAv10']=data['y'].rolling(window=10).mean()

data = data.fillna(method='bfill')

X_train = data.drop(columns=['ds', 'направление'])
Y_train = data['направление']

bst = xgb.XGBClassifier(use_label_encoder=False, eval_metrics='logloss')
bst.fit(X_train,Y_train)

yhat = pd.DataFrame({'y':data['y'].tolist()+final_predict.tolist(),'y_stationary':forecast['yhat'].tolist()})
yhat['lag2']=yhat['y'].shift(2)
yhat['lag3']=yhat['y'].shift(3)
yhat['y_lag2']=yhat['y']-yhat['lag2']
yhat['y_lag3']=yhat['y']-yhat['lag3']
yhat['MovAv10']=yhat['y'].rolling(window=10).mean()

yhat = yhat.fillna(method='bfill')

binary_predict = bst.predict(yhat[-40:])

with open('forecast_class.json', 'w') as file:
    json.dump(binary_predict.tolist(), file)

print(binary_predict)